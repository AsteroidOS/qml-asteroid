#!/usr/bin/python3
import pandas as pd
import numpy as np
import pyvista as pv
import math
import random

# We can choose this constant to make the FlatMesh look more or less low-poly
nb_points = 100

# Find the radius of nb_points packed circles from www.packomania.com
radius_table = pd.read_csv("http://hydra.nat.uni-magdeburg.de/packing/cci/txt/radius.txt", header=None, sep=' ')
radius = float(radius_table[radius_table[0]==nb_points][1])

# Download the coordinates of nb_points optimally packed circles
points = pd.read_csv("http://hydra.nat.uni-magdeburg.de/packing/cci/txt/cci" + str(nb_points) + ".txt", sep=' ',
        skipinitialspace=True, header=None).drop(columns=0).to_numpy()

# Import these points as a 3D points cloud in PyVista
cloud = pv.PolyData(np.hstack((points, np.zeros((points.shape[0], 1)))))

# Generate a Delaunay triangulation of this points cloud
mesh = cloud.delaunay_2d()

# Find a series of triangle strips (see GL_TRIANGLE_STRIP) that describes this mesh
strips = mesh.strip()

# Coordinates can be repeated if a point at x, y needs different color mixes as the last point of different triangles
# However, we try to de-duplicate vertices as much as we can and use an index array to point back to this buffer
vertices = []
indices = []

# Each vertex is represented as a tuple of: x, y (its base coordinates, before any shift) and a color mixing ratio
def add_vertex(index, mix=None):
    x, y = points[index]

    # Re-use existing vertices as much as possible
    for i, vertex in enumerate(vertices):
        if vertex[0] == x and vertex[1] == y:
            if vertex[2] == None:
                vertices[i] = (x, y, mix)

            if vertices[i][2] == mix or mix == None:
                indices.append(i)
                return

    # If we haven't found a vertex to recycle, create a new one
    indices.append(len(vertices))
    vertices.append((x, y, mix))

# The color mixing ratio of a triangle depends on the distance of its baricenter to the center
def triangle_color_mix(index0, index1, index2):
    x0, y0 = points[index0]
    x1, y1 = points[index1]
    x2, y2 = points[index2]

    x = (x0+x1+x2)/3
    y = (y0+y1+y2)/3

    distance_to_center = math.sqrt(x**2 + y**2)
    # Stretch the distance a little bit to use the full [0:1] range
    distance_to_center *= 1.2

    # Add a non-linearity (power 1.7) to make the gradient more interesting
    mix = distance_to_center**1.7
    return min(mix, 1.0)

# Iterate over all the strips found by PyVista
strip_len_index = 0
for i in range(strips.n_strips):
    strip_len = strips.strips[strip_len_index]
    # The first two points of the strip don't need a color mix
    add_vertex(strips.strips[strip_len_index+1])
    add_vertex(strips.strips[strip_len_index+2])
    # Iterate over all the other points of the strip
    for i in range(strip_len_index+3, strip_len_index+1+strip_len):
        index = strips.strips[i]
        add_vertex(index, triangle_color_mix(strips.strips[i-2], strips.strips[i-1], index))

    strip_len_index = strip_len_index + 1 + strip_len

    # Start a new strip using GL_PRIMITIVE_RESTART
    if not strip_len_index == len(strips.strips):
        indices.append(0xffff)

# Generate a C++ header that contains the vertices/indices/shifts
out = open("flatmeshgeometry.h", "w")
out.write("// Do not modify manually! This file is generated by generate_flatmeshgeometry.py\n\n")

# Output the vertices and their color mix attribute (VAO in OpenGL terminology)
out.write("static const QVector3D flatmesh_vertices[] = {\n")
for vertex in vertices:
    x = vertex[0]
    y = vertex[1]
    mix = vertex[2] if vertex[2] is not None else 0.0
    out.write("    QVector3D(" + str(x/2) + ", " + str(y/2) + ", " + str(mix) + "),\n")
out.write("};\n")
out.write("static const int flatmesh_vertices_sz = " + str(len(vertices)) + ";\n\n")

# Output the indices (EBO in OpenGL terminology)
out.write("static const unsigned short flatmesh_indices[] = {\n")
for index in indices:
    out.write("    " + str(index) + ",\n")
out.write("};\n")
out.write("static const int flatmesh_indices_sz = " + str(len(indices)) + ";\n\n")

# Pre-calculate a bunch of random shifts to save the watch some computing (https://xkcd.com/221/)
# A power of 2 here lets the compiler implement the modulo as a cheap AND bit-mask
random_shifts_nb = 128
out.write("static const float flatmesh_shifts[] = {\n")
for i in range(random_shifts_nb):
    # This sqrt() compensates the otherwise non-uniform probability distribution
    r = radius * math.sqrt(random.random())
    alpha = 2 * math.pi * random.random()

    x = r * math.cos(alpha)
    y = r * math.sin(alpha)
    out.write("    " + str(x/2) + ", " + str(y/2) + ",\n")
out.write("};\n")
out.write("static const int flatmesh_shifts_nb = " + str(random_shifts_nb) + ";\n")
# For use by the inlined shader code
out.write("#define FLATMESH_SHIFTS_NB_STR \"" + str(random_shifts_nb) + "\"")

out.close()

# Output some statistics to make GPU memory usage more tractable
vertices_bytes = len(vertices)*(2*4+3) # Each vertex takes 2 floats and 3 chars
print(str(len(vertices)) + " vertices take " + str(vertices_bytes) + " bytes")
indices_bytes = len(indices)*2 # Each index takes 1 short
print(str(len(indices)) + " indices take " + str(indices_bytes) + " bytes")
shifts_bytes = random_shifts_nb*2*4 # Each shift takes 2 floats
print(str(random_shifts_nb) + " shifts take " + str(shifts_bytes) + " bytes")

# With a total taking less than a page (4096B), we can be satisfied
print("Total takes " + str(vertices_bytes+indices_bytes+shifts_bytes) + " bytes")
